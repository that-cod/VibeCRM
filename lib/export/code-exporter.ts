/**
 * @fileoverview Code Exporter
 * 
 * Reasoning:
 * - Generate downloadable ZIP files
 * - Create project structure
 * - Include README and configuration
 */

import type { ProjectPlan, CodeFile } from "@/lib/code-generator/schemas";

export interface ExportOptions {
  projectPlan: ProjectPlan;
  codeFiles: CodeFile[];
  databaseSchema: string;
  includeReadme?: boolean;
  includePackageJson?: boolean;
}

export interface GeneratedFile {
  path: string;
  content: string;
}

/**
 * Generate complete project structure for export
 */
export function generateExportFiles(options: ExportOptions): GeneratedFile[] {
  const files: GeneratedFile[] = [];

  // Add code files
  for (const codeFile of options.codeFiles) {
    files.push({
      path: codeFile.path,
      content: codeFile.content,
    });
  }

  // Add README
  if (options.includeReadme !== false) {
    files.push({
      path: "README.md",
      content: generateReadme(options.projectPlan),
    });
  }

  // Add package.json
  if (options.includePackageJson !== false) {
    files.push({
      path: "package.json",
      content: generatePackageJson(options.projectPlan),
    });
  }

  // Add database schema
  files.push({
    path: "supabase/schema.sql",
    content: options.databaseSchema,
  });

  // Add .env.example
  files.push({
    path: ".env.example",
    content: generateEnvExample(),
  });

  // Add next.config.js
  files.push({
    path: "next.config.js",
    content: generateNextConfig(),
  });

  // Add tsconfig.json
  files.push({
    path: "tsconfig.json",
    content: generateTsConfig(),
  });

  // Add tailwind.config.js
  files.push({
    path: "tailwind.config.js",
    content: generateTailwindConfig(),
  });

  return files;
}

/**
 * Generate README content
 */
function generateReadme(plan: ProjectPlan): string {
  return `# ${plan.name}

${plan.description}

## Resources

${plan.resources.map(r => `
### ${r.plural_label}
- **Route:** /\`${r.plural_name}\`
- **Icon:** ${r.icon}
- **Fields:** ${r.fields.length}
${r.relationships?.map(rel => `  - Related to: ${rel.related_resource}`).join("\n") || ""}
`).join("\n")}

## Getting Started

1. Install dependencies:
\`\`\`bash
npm install
\`\`\`

2. Set up environment variables:
\`\`\`bash
cp .env.example .env.local
\`\`\`

3. Run the development server:
\`\`\`bash
npm run dev
\`\`\`

4. Open [http://localhost:3000](http://localhost:3000)

## Database Setup

Run the SQL in \`supabase/schema.sql\` in your Supabase SQL Editor.

## Tech Stack

- Next.js 15
- TypeScript
- Refine.dev
- shadcn/ui
- Tailwind CSS
- Supabase

Generated by VibeCRM - AI-Native CRM Platform
`;
}

/**
 * Generate package.json content
 */
function generatePackageJson(plan: ProjectPlan): string {
  return `{
  "name": "${plan.name.toLowerCase().replace(/\s+/g, "-")}",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbo",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.32.1",
    "@hookform/resolvers": "^5.2.2",
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-label": "^2.1.8",
    "@radix-ui/react-select": "^2.1.15",
    "@radix-ui/react-separator": "^1.1.2",
    "@radix-ui/react-slot": "^1.1.2",
    "@supabase/ssr": "^0.5.2",
    "@supabase/supabase-js": "^2.47.10",
    "@tanstack/react-table": "^8.21.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "lucide-react": "^0.562.0",
    "next": "^15.1.4",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-hook-form": "^7.70.0",
    "sonner": "^2.0.7",
    "tailwind-merge": "^3.4.0",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@types/node": "^22.10.5",
    "@types/react": "^19.0.6",
    "@types/react-dom": "^19.0.2",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.18.0",
    "eslint-config-next": "^15.1.4",
    "postcss": "^8.4.49",
    "tailwindcss": "^3.4.17",
    "typescript": "^5.7.3"
  }
}
`;
}

/**
 * Generate .env.example content
 */
function generateEnvExample(): string {
  return `# Supabase
NEXT_PUBLIC_SUPABASE_URL=your-project-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key

# Anthropic (Claude AI)
ANTHROPIC_API_KEY=your-anthropic-api-key
`;
}

/**
 * Generate next.config.js
 */
function generateNextConfig(): string {
  return `/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    serverActions: {
      bodySizeLimit: '2mb',
    },
  },
};

module.exports = nextConfig;
`;
}

/**
 * Generate tsconfig.json
 */
function generateTsConfig(): string {
  return `{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [{ "name": "next" }],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
`;
}

/**
 * Generate tailwind.config.js
 */
function generateTailwindConfig(): string {
  return `/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}
`;
}

/**
 * Convert files to ZIP format (returns base64)
 * In a real implementation, you'd use a library like adm-zip or jszip
 */
export async function createZipFromFiles(files: GeneratedFile[]): Promise<string> {
  // This is a placeholder - in production, use a proper ZIP library
  console.log(`Would create ZIP with ${files.length} files`);
  
  // For now, return a mock response
  return "ZIP_BASE64_PLACEHOLDER";
}

/**
 * Download files as a ZIP
 */
export async function downloadAsZip(options: ExportOptions): Promise<void> {
  const files = generateExportFiles(options);
  
  // In a real implementation:
  // 1. Use JSZip to create the archive
  // 2. Generate blob from the archive
  // 3. Trigger download
  
  console.log(`Generated ${files.length} files for export`);
  
  // Log file structure for debugging
  for (const file of files) {
    console.log(`  - ${file.path}`);
  }
}
